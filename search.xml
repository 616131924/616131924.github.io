<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>零散知识点（持续更新）</title>
      <link href="/2020/03/28/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2020/03/28/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="零碎知识点记录"><a href="#零碎知识点记录" class="headerlink" title="零碎知识点记录"></a>零碎知识点记录</h1><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ul><li><a href="#1-new-Foo()执行时发了什么">1. new Foo()执行时发了什么</a></li><li><a href="#2-手动实现一个new">2. 手动实现一个new</a></li></ul><h2 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h2><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h3><h4 id="1-new-Foo-执行时发了什么"><a href="#1-new-Foo-执行时发了什么" class="headerlink" title="1 new Foo()执行时发了什么"></a>1 new Foo()执行时发了什么</h4><pre><code>1.一个继承自 Foo.prototype 的新对象被创建。2.使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。3.由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</code></pre><h4 id="2-手动实现一个new"><a href="#2-手动实现一个new" class="headerlink" title="2 手动实现一个new"></a>2 手动实现一个new</h4><pre><code>function myNew(myConsrtuctor,...args){    var newObject = {}    // 设置原型对象    newObject.__proto__ = myConsrtuctor.prototype    // 调用构造函数    var constructorObject = myConsrtuctor.apply(newObject,args)    // 如果构造函数有返回值则调用构造函数的返回值    return constructorObject? constructorObject :newObject}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript事件循环</title>
      <link href="/2020/03/19/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/2020/03/19/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaSript中的事件循环机制"><a href="#JavaSript中的事件循环机制" class="headerlink" title="JavaSript中的事件循环机制"></a>JavaSript中的事件循环机制</h1><p>JavaScript中的代码运行都是单线程的，需要保持线程中的事件执行就需要有一个事件循环的机制，本文将讲述JavaScript维持事件执行的事件循环机制。由于Node环境与浏览器环境的事件循环有差距，所以本文会分开来讲述。</p><h3 id="事件循环概念"><a href="#事件循环概念" class="headerlink" title="事件循环概念"></a>事件循环概念</h3><p>JavaScript中的事件循环由两个任务队列来组成，分别是宏任务队列(macro-task)与微任务队列(micro-task)，两个任务队列间的执行顺序如下图所示。<br><img src="https://user-gold-cdn.xitu.io/2018/9/16/165e1427075ec517?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"><br>具体描述：先执行宏任务，然后执行宏任务中产生的微任务，如果微任务中产生宏任务，则将宏任务放入下一轮循环的宏任务队列中，如果微任务中产生微任务，则继续执行新产生的微任务直到所有微任务结束，然后在执行下一轮的宏任务。</p><h2 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h2><h5 id="浏览器中的宏任务包括："><a href="#浏览器中的宏任务包括：" class="headerlink" title="浏览器中的宏任务包括："></a>浏览器中的宏任务包括：</h5><ul><li>script(整体代码)</li><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>UI render<h5 id="浏览器中的微任务包括："><a href="#浏览器中的微任务包括：" class="headerlink" title="浏览器中的微任务包括："></a>浏览器中的微任务包括：</h5></li><li>process.nextTick</li><li>Promise的then与catch</li><li>Async/Await(实际就是promise)</li><li>MutationObserver(html5新特性)<h5 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h5></li></ul><pre><code>console.log(&#39;script start&#39;)async function async1() {    await async2()    console.log(&#39;async1 end&#39;)}async function async2() {    console.log(&#39;async2 end&#39;)}async1()setTimeout(function() {    console.log(&#39;setTimeout&#39;)}, 0)new Promise(resolve =&gt; {    console.log(&#39;Promise&#39;)    resolve()}).then(function() {    console.log(&#39;promise1&#39;)    setTimeout(function() {        console.log(&#39;inside-timeout&#39;)        new Promise(resolve =&gt; {            console.log(&#39;inside-Promise&#39;)            resolve()        }).then(function(){            console.log(&#39;inside-promise1&#39;)        })}, 0)}).then(function() {    console.log(&#39;promise2&#39;)})console.log(&#39;script end&#39;)</code></pre><p>输出的结果如下：</p><ol><li>script start</li><li>async2 end</li><li>Promise</li><li>script end</li><li>async1 end</li><li>promise1</li><li>promise2</li><li>setTimeout</li><li>inside-timeout</li><li>inside-Promise</li><li>inside-promise1</li></ol><p>执行顺序果分析：</p><ol><li><p>执行整体代码（作为当前宏任务），输出<strong>script start</strong></p></li><li><p>整体代码按顺序执行遇到<strong>async1()</strong>，进入<strong>async1</strong>遇到<strong>await async2()</strong>,<strong>ascyn2()</strong> 即执行函数 <strong>async2</strong>，输出<strong>async2 end</strong>，由于<strong>async2()</strong>没有返回值，所以相当于 <strong>await undefined</strong>,即会将后面的代码放入微任务队列</p><table><thead><tr><th>宏任务</th><th>微任务</th></tr></thead><tbody><tr><td>无</td><td>console.log(‘async1 end’)</td></tr></tbody></table></li><li><p>遇到<strong>setTimeout()</strong>,将setTimeout的回调压入宏任务队列，目前事件循环宏任务队列与微任务队列如下：</p></li></ol><table><thead><tr><th>宏任务</th><th>微任务</th></tr></thead><tbody><tr><td>setTimeout</td><td>console.log(‘async1 end’)</td></tr><tr><td>4.执行<strong>new Promise()</strong>,输出<strong>Promise</strong>，然后由于执行resolve的缘故，所以会将当前promise的then的回调函数压入微任务。</td><td></td></tr></tbody></table><table><thead><tr><th>宏任务</th><th>微任务</th></tr></thead><tbody><tr><td>setTimeout</td><td>console.log(‘async1 end’)</td></tr><tr><td>无</td><td>Promise.then(第一个then)</td></tr><tr><td>5.当前宏任务执行之最后一行，<strong>console.log(‘script end’)</strong>，输出<strong>script end</strong>当前宏任务结束，开始执行当前宏任务所产生的微任务，目前队列如下所示</td><td></td></tr><tr><td>宏任务</td><td>微任务</td></tr><tr><td>—</td><td>—</td></tr><tr><td>setTimeout</td><td>console.log(‘async1 end’)</td></tr><tr><td>无</td><td>Promise.then(第一个then)</td></tr><tr><td>6. 执行微任务队列第一个任务<strong>console.log(‘async1 end’)</strong>,输出<strong>async1 end</strong></td><td></td></tr><tr><td>7. 继续执行微任务队列中的<strong>Promise.then()</strong>，代码如下</td><td></td></tr></tbody></table><pre><code>.then(function() {    console.log(&#39;promise1&#39;)    setTimeout(function() {        console.log(&#39;inside-timeout&#39;)        new Promise(resolve =&gt; {            console.log(&#39;inside-Promise&#39;)            resolve()        }).then(function(){            console.log(&#39;inside-promise1&#39;)        })}, 0)})</code></pre><p>首先输出<strong>promise1</strong>，然后将settimeout1放入宏队列<br>宏任务 | 微任务<br>—|—<br>setTimeout | Promise.then(第一个then)<br>setTimeout1 | 无<br>8.<strong>Promise.then</strong>(第一个then)执行完后遇到第二个<strong>Promise.then</strong>，目前在微任务执行中产生新的微任务则继续执行产生的微任务，输出<strong>promise2</strong><br>9.目前微任务队列已清空，则执行宏任务队列中的任务，首先执行<strong>setTimeout</strong>，输出<strong>setTimeout</strong><br>10.继续执行<strong>settimeout1</strong>，settimeout1会产生新的微任务，执行完settimeout1后开始执行所产生的微任务。</p><h2 id="Node中的事件循环"><a href="#Node中的事件循环" class="headerlink" title="Node中的事件循环"></a>Node中的事件循环</h2><p>Node中的事件循环是指Node.js执行非阻塞I/O操作的机制，与浏览器中的事件循环有所不同。<br>下面是Node中具体的事件循环过程</p><pre><code>   ┌───────────────────────────┐┌─&gt;│           timers          ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐│  │     pending callbacks     ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐│  │       idle, prepare       ││  └─────────────┬─────────────┘      ┌───────────────┐│  ┌─────────────┴─────────────┐      │   incoming:   ││  │           poll            │&lt;─────┤  connections, ││  └─────────────┬─────────────┘      │   data, etc.  ││  ┌─────────────┴─────────────┐      └───────────────┘│  │           check           ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐└──┤      close callbacks      │   └───────────────────────────┘</code></pre><ul><li>incoming阶段：处理已提供的输入脚本（或丢入 REPL，本文不涉及到），它可能会调用一些异步的 API、调度定时器，或者调用 process.nextTick()，然后开始处理事件循环。</li><li>timers 阶段: 这个阶段执行 setTimeout(callback) 和 setInterval(callback) 预定的 callback;</li><li>I/O callbacks 阶段: 此阶段执行某些系统操作的回调，例如TCP错误的类型。 例如，如果TCP套接字在尝试连接时收到 ECONNREFUSED，则某些* nix系统希望等待报告错误。 这将操作将等待在==I/O回调阶段==执行;</li><li>idle, prepare 阶段: 仅node内部使用;</li><li>poll 阶段: 获取新的I/O事件, 例如操作读取文件等等，适当的条件下node将阻塞在这里;</li><li>check 阶段: 执行 setImmediate() 设定的callbacks;</li><li>close callbacks 阶段: 比如 socket.on(‘close’, callback) 的callback会在这个阶段执行;</li></ul><h4 id="Poll阶段（轮询阶段）"><a href="#Poll阶段（轮询阶段）" class="headerlink" title="Poll阶段（轮询阶段）"></a>Poll阶段（轮询阶段）</h4><h5 id="轮询-阶段有两个重要的功能："><a href="#轮询-阶段有两个重要的功能：" class="headerlink" title="轮询 阶段有两个重要的功能："></a>轮询 阶段有两个重要的功能：</h5><ul><li>计算应该阻塞和轮询 I/O 的时间。</li><li>然后，处理 轮询 队列里的事件。<br>当事件循环进入 轮询 阶段且 没有被调度的计时器时 ，将发生以下两种情况之一：</li></ul><p>如果轮询队列 不是空的 ，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制。<br>如果轮询队列是空的 ，还有两件事发生：</p><p>如果脚本被 setImmediate() 调度，则事件循环将结束 轮询 阶段，并继续 检查 阶段以执行那些被调度的脚本。</p><p>如果脚本 未被 setImmediate()调度，则事件循环将等待回调被添加到队列中，然后立即执行。</p><p>一旦 轮询 队列为空，事件循环将检查 已达到时间阈值的计时器。如果一个或多个计时器已准备就绪，则事件循环将绕回（timer）计时器阶段以执行这些计时器的回调。</p><h4 id="check阶段（检查阶段）"><a href="#check阶段（检查阶段）" class="headerlink" title="check阶段（检查阶段）"></a>check阶段（检查阶段）</h4><p>此阶段允许人员在轮询阶段完成后立即执行回调。如果轮询阶段变为空闲状态，并且脚本使用 setImmediate() 后被排列在队列中，则事件循环可能继续到 检查 阶段而不是等待。</p><p>setImmediate() 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个 libuv API 来安排回调在 轮询 阶段完成后执行。</p><p>通常，在执行代码时，事件循环最终会命中轮询阶段，在那等待传入连接、请求等。但是，如果回调已使用 setImmediate()调度过，并且轮询阶段变为空闲状态，则它将结束此阶段，并继续到检查阶段而不是继续等待轮询事件。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript消息驱动</title>
      <link href="/2020/03/17/JavaScript%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/"/>
      <url>/2020/03/17/JavaScript%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript消息驱动源码"><a href="#JavaScript消息驱动源码" class="headerlink" title="JavaScript消息驱动源码"></a>JavaScript消息驱动源码</h1><pre><code class="javascript">export default class EventWait {  constructor () {    // 消息驱动触发的事件对象    this.eventHandler = {}    // 等待的消息队列    this.waitingList = []    this._this = this  }  waitFor (waitList, handler, thisObj, ...parmas) {    if (typeof resources === &#39;string&#39;) waitList = [waitList]    if (waitList.length === 0) {      this.runHandler(handler, parmas)      return    }    if (thisObj) this._this = thisObj    this.eventHandler = {      &#39;waiting&#39;: waitList.slice(0),      &#39;handler&#39;: handler,      &#39;parmas&#39;: parmas    }    this.waitingList = waitList  }  // 消息驱动完成后的事件调用  runHandler (handler, parmas) {    if (typeof handler === &#39;function&#39;) {      // 将事件放入下一个事件队列中执行，否则会影响当前的事件执行顺序      setTimeout(() =&gt; {        handler.apply(this._this, parmas)      }, 0)    }  }  // 外部调用的触发消息驱动方法（通知）  trigger (waitItem) {    if (typeof waitItem === &#39;string&#39;) waitItem = [waitItem]    for (let i = 0; i &lt; waitItem.length; i++) {      let wait = waitItem[i]      if (!this.waitingList.includes(wait)) return      this.release(wait)    }  }  // 释放消息驱动队列  release (waitItem) {    if (typeof waitItem === &#39;string&#39;) waitItem = [waitItem]    for (let i = 0; i &lt; waitItem.length; i++) {      if (this.eventHandler.waiting.includes(waitItem[i])) {        let pos = this.eventHandler.waiting.indexOf(waitItem[i])        this.eventHandler.waiting.splice(pos, 1)        if (this.eventHandler.waiting.length === 0) {          this.runHandler(this.eventHandler.handler, this.eventHandler.parmas)        }      }    }  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Javascript中的原型与原型链</title>
      <link href="/2020/03/13/js-prototype/"/>
      <url>/2020/03/13/js-prototype/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈JavaScript中的原型与原型链"><a href="#浅谈JavaScript中的原型与原型链" class="headerlink" title="浅谈JavaScript中的原型与原型链"></a>浅谈JavaScript中的原型与原型链</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h6 id="1-分享这篇文章的目的"><a href="#1-分享这篇文章的目的" class="headerlink" title="1.分享这篇文章的目的"></a>1.分享这篇文章的目的</h6><p>原型和原型链其实一直是我的一个知识盲区，一直我都是通过死记硬背的方式来记住他们，但时间过久了，原型和原型链的知识点很快就会变得模糊，因为他们之间的关系是比较复杂的。特别是看到下面这种图的时候。<br><img src="https://img-blog.csdnimg.cn/20190311194017886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjMTg4Njg4NzY4Mzc=,size_16,color_FFFFFF,t_70" alt="image"><br>如此复杂的关系是很难靠死记硬背记住的，其实我们只需要知道了解原型和原型链的背景，然后再去理清prototype，__proto__，constructor三者各自的含义，自然就能很好的理解JavaScript中原型与原型链到底是个什么东西了</p><h6 id="2-为什么要理解原型与原型链"><a href="#2-为什么要理解原型与原型链" class="headerlink" title="2.为什么要理解原型与原型链"></a>2.为什么要理解原型与原型链</h6><p>JavaScript是一门面向对象的语言，身为前端工程师，天天都用着JavaScript，但却不知道他到底是怎么面向对象的，这种问题一直都是很多前端工程师的痛点，工作中很少用到，并不意味着我们就能不知道，万一哪天产品提需求让你写一个Vue呢？</p><h3 id="JS中的原型与原型链概念"><a href="#JS中的原型与原型链概念" class="headerlink" title="JS中的原型与原型链概念"></a>JS中的原型与原型链概念</h3><h5 id="原型诞生的背景"><a href="#原型诞生的背景" class="headerlink" title="原型诞生的背景"></a>原型诞生的背景</h5><p>要讲清楚原型的概念，我们必须了解其背景。JavaScript是一门面向对象的语言，即使我们平时的工作好像不怎么面向对象，但这是不能否认的事实。而设计JavaScript的<strong><em>Brendan Eich</em></strong>大神，认为JavaScript只是一个脚本语言并不需要太过庞大的面向对象体系，所以在综合的考虑下，他选择了基于原型的面向对象设计，从一开始原型的概念就已经加入到了JavaScript中。</p><h5 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h5><h6 id="1-原型"><a href="#1-原型" class="headerlink" title="1.原型"></a>1.原型</h6><p>JavaScript中原型概念与设计模式中的原型模式是一致的，所有的对象都是从另一个对象克隆得来，在创建对象前需要先获取到被创建对象的原型对象，然后进行拷贝形成一个新的对象，而被创建对象中会保存一个指针，该指针指向其原型对象。</p><h6 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1.原型链"></a>1.原型链</h6><p>在描述原型这个概念的时候，已经说到在对象被创建后会在对象内保存一个原型对象的指针，当生成一个对象B，对象B的原型对象是A，生成一个对象C，对象C的原型对象是对象B,于是就会形成A&lt;-B&lt;-C的单向链结构,而这条链就是原型链，也正是形成了这样的单向链结构，巧妙的利用原型模式在JavaScript中完成了’继承’的实现</p><h3 id="JS中的原型与原型链体现"><a href="#JS中的原型与原型链体现" class="headerlink" title="JS中的原型与原型链体现"></a>JS中的原型与原型链体现</h3><h6 id="1-proto"><a href="#1-proto" class="headerlink" title="1.proto"></a>1.<strong>proto</strong></h6><p><img src="https://img-blog.csdnimg.cn/20190311192930650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjMTg4Njg4NzY4Mzc=,size_16,color_FFFFFF,t_70" alt="image"><br><strong>proto</strong>是每个对象都会具备的属性，该属性是一个引用指向当前对象的原型对象，即指向原型prototype，至于为什么prototype前面会有Object.,Foo.,后面的内容会讲到。而<strong>proto</strong>的指向其实就是原型链的指向，当访问图中f1变量中不存在的属性时会沿着<strong>proto</strong>指向访问下一个原型对象，如果直到最后都没有找到匹配的属性，那么就会变成null.xxxx，这个时候就会报错。</p><p>在JavaScript的发展历史中，<strong>proto</strong>在一开始并不是ECMAScript规范的内容，而是部分浏览器私自挂载在对象上的一个属性，该属性指向了当前对象的原型对象。而到了ECMAScript2015规范中，<strong>proto</strong>才被纳入规范。</p><p><img src="https://7a79-zy-test-1257835692.tcb.qcloud.la/1573549832885_%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15735493019131.png?sign=ee0b28cf69ad155d88fcd866c8a8a4b5&t=1573550066" alt="image"></p><p>从截图中看出，其实对象中的<strong>proto</strong>属性是被get/set封装过，其实get/set的封装就相当于分别调用Object.getPrototyoeOf(this)/Object.setPrototyoeOf(this,vale) 两个方法来获取当前对象的原型对象</p><h6 id="2-prototype"><a href="#2-prototype" class="headerlink" title="2.prototype"></a>2.prototype</h6><p><img src="https://img-blog.csdnimg.cn/20190311193033876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjMTg4Njg4NzY4Mzc=,size_16,color_FFFFFF,t_70" alt="!image"></p><p> 1.1 prototype的真正含义</p><p>prototype的翻译就是原型的意思，从ES2019规范里prototype被描述为一个给其他对象提供共享属性的对象，这句话表明了prototype本身是一个对象，这个对象的职能是为其他对象提供克隆的模板。在JavaScript中，prototype是作为一个独立的对象存在。</p><p> 1.2 函数中的prototype属性</p><p>在JavaScript中，函数是一个很特别的存在，函数也是对象它具有自己的原型（即<strong>proto</strong>），但函数也能作为某个对象的构造函数而存在。作为构造函数，该函数的作用就是按照指定的原型对象创建一个具体的对象，而指定的原型对象则会保存在函数的prototype属性中，而被创建出来的具体对象中的<strong>proto</strong>会指向该函数的prototype。</p><h6 id="3-contructor"><a href="#3-contructor" class="headerlink" title="3.contructor"></a>3.contructor</h6><p><img src="https://img-blog.csdnimg.cn/20190311193745414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjMTg4Njg4NzY4Mzc=,size_16,color_FFFFFF,t_70" alt="!image"><br>由图中可以看出constructor属性指向当前对象的构造函数，实例对象中是不存在constructor属性的（手动添加constructor属性除外），但能通过原型链的访问到原型对象上的constructor属性，也就是说constructor属性是存在于prototype中的。</p><h3 id="原型与原型链的应用"><a href="#原型与原型链的应用" class="headerlink" title="原型与原型链的应用"></a>原型与原型链的应用</h3><h5 id="浅析Vue源码内原型与原型链的使用"><a href="#浅析Vue源码内原型与原型链的使用" class="headerlink" title="浅析Vue源码内原型与原型链的使用"></a>浅析Vue源码内原型与原型链的使用</h5><h6 id="1-从Vue-extend了解Vue实例与VueComponent实例间的继承"><a href="#1-从Vue-extend了解Vue实例与VueComponent实例间的继承" class="headerlink" title="1.从Vue.extend了解Vue实例与VueComponent实例间的继承"></a>1.从Vue.extend了解Vue实例与VueComponent实例间的继承</h6><p>首先，我们经常在代码中操作组件中的this，我们先将this输出来看看。</p><pre><code class="javascript">VueComponet{    $attrs: (...)    ...    __proto__: Vue}</code></pre><p>如上代码所示，其实每一个组件都是由一个Vue原型对象创建而来，在Vue的说明文档中，Vue.extend的解析为‘使用基础 Vue 构造器，创建一个“子类”’，转成代码的意思是Vue.extend生成一个组件构造函数，如下代码所示。</p><pre><code class="javascript"> Vue.extend = function (extendOptions: Object): Function {    ...1    const Super = this    ...2    const Sub = function VueComponent (options) {      this._init(options)    }3   Sub.prototype = Object.create(Super.prototype)    ...4   return Sub  }}</code></pre><p>实现Vue与VueComponet之间的继承分为以下三步：</p><p>1.利用Super变量保存当前的调用extend方法的Vue实例对象</p><p>2.进行VueComponet构造函数的编写</p><p>3.指定构造函数中的prototype属性，即告诉构造函数需要根据指定的prototype进行对象的创建，而prototype指向的是利用Object.create(Vue当前实例对象)创建出来的对象，此时就VueComponent实例对象就能够访问到Vue实例对象上的属性，也就形成了所说的原型链，其中继承已经在这一步完成了。</p><p>4.最后一步则将VueComponet的构造函数返回，也就完成了Vue文档中‘创建一个“子类”’的说法</p><h6 id="2-this-emit方法挂载"><a href="#2-this-emit方法挂载" class="headerlink" title="2.this.$emit方法挂载"></a>2.this.$emit方法挂载</h6><pre><code class="javascript"> Vue.prototype.$emit = function (event: string): Component {    const vm: Component = this   ...    return vm  }</code></pre><p>this.$emit()方法其实并不是VueComponet实例对象上的方法，而是VueComponet继承了Vue对象，继而形成了原型链，当访问到VueComponet.$emit()时会访问Vue.$emit(),而源码中$emit()是通过以上方法挂载到Vue对象上的。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h6 id="编写一个实现继承的函数"><a href="#编写一个实现继承的函数" class="headerlink" title="编写一个实现继承的函数"></a>编写一个实现继承的函数</h6><p>该函数传入一个构造函数a与一个构造函数b和b类中需要的属性，返回一个b类继承a类后新的的构造函数</p><pre><code class="javascript"> const inherit =(fatherConstructor,sonConstructor,properties) =&gt;{   1  let subConstructor = function(...properties){         fatherConstructor.call(this,...properties)         sonConstructor.call(this,...properties)        }   2  subConstructor.prototype ={         ...properties,         constructor:subConstructor        }   3  Object.setPrototypeOf(        subConstructor.prototype,        fatherConstructor.prototype     )     return subConstructor }</code></pre><p>步骤分析：</p><p>1.创建一个新的构造函数（称为c构造函数），该函数内部调用了父类与子类的构造函数，确保构造函数中初始化的时候与父类和子类一致。</p><p>2.新建一个新构造函数的原型对象，里面要保有所有b类的属性和指向c构造函数的constructor属性</p><p>3.将c构造函数的原型对象即subConstructor.prototype的指向对象的<strong>proto</strong>指向父级的原型对象即fatherConstructor.prototype</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.JavaScript的面向对象是基于原型模式来设计的</p><p>2.JavaScript的继承是通过原型链来实现的</p><p>3.JavaScript中函数能作为构造函数并用new function()来构建对象。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript基础 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
